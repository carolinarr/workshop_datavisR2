<!DOCTYPE html><html><head><title>R: Axes for Transformed Variables</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table style="width: 100%;"><tr><td>TransformationAxes {car}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='TransformationAxes'>Axes for Transformed Variables</h2>

<h3>Description</h3>

<p>These functions produce axes for the original scale of 
transformed variables. Typically these would appear as additional
axes to the right or
at the top of the plot, but if the plot is produced with 
<code>axes=FALSE</code>, then these functions could be used for axes below or to
the left of the plot as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicPowerAxis(power, base=exp(1), 
    side=c("right", "above", "left", "below"), 
    at, start=0, lead.digits=1, n.ticks, grid=FALSE, grid.col=gray(0.50), 
    grid.lty=2,
    axis.title="Untransformed Data", cex=1, las=par("las"))

bcPowerAxis(power, side=c("right", "above", "left", "below"), 
    at, start=0, lead.digits=1, n.ticks, grid=FALSE, grid.col=gray(0.50), 
    grid.lty=2,
    axis.title="Untransformed Data", cex=1, las=par("las"))
    
bcnPowerAxis(power, shift, side=c("right", "above", "left", "below"), 
    at, start=0, lead.digits=1, n.ticks, grid=FALSE, grid.col=gray(0.50), 
    grid.lty=2,
    axis.title="Untransformed Data", cex=1, las=par("las"))
    
yjPowerAxis(power, side=c("right", "above", "left", "below"), 
	at, lead.digits=1, n.ticks, grid=FALSE, grid.col=gray(0.50), 
  grid.lty=2,
	axis.title="Untransformed Data", cex=1, las=par("las"))

probabilityAxis(scale=c("logit", "probit"), 
	side=c("right", "above", "left", "below"),
	at, lead.digits=1, grid=FALSE, grid.lty=2, grid.col=gray(0.50),
    axis.title = "Probability", interval = 0.1, cex = 1, las=par("las"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransformationAxes_:_power">power</code></td>
<td>
<p>power for Box-Cox, Box-Cox with negatives, Yeo-Johnson, or simple power transformation.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_shift">shift</code></td>
<td>
<p>the shift (gamma) parameter for the Box-Cox with negatives family.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_scale">scale</code></td>
<td>
<p>transformation used for probabilities, <code>"logit"</code>
(the default) or <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_side">side</code></td>
<td>
<p>side at which the axis is to be drawn; numeric
codes are also permitted: <code>side = 1</code> for the bottom of the plot,
<code>side=2</code> for the left side, 
<code>side = 3</code> for the top, <code>side = 4</code> for the right side.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_at">at</code></td>
<td>
<p>numeric vector giving location of tick marks on
original scale; if missing, the function will try to pick
nice locations for the ticks.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_start">start</code></td>
<td>
<p>if a <em>start</em> was added to a variable (e.g., to make all
data values positive), it can now be subtracted from the tick labels.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_lead.digits">lead.digits</code></td>
<td>
<p>number of leading digits for determining &lsquo;nice&rsquo; numbers 
for tick labels (default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_n.ticks">n.ticks</code></td>
<td>
<p>number of tick marks; if missing, same as corresponding
transformed axis.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_grid">grid</code></td>
<td>
<p>if <code>TRUE</code> grid lines for the axis will be drawn.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_grid.col">grid.col</code></td>
<td>
<p>color of grid lines.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_grid.lty">grid.lty</code></td>
<td>
<p>line type for grid lines.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_axis.title">axis.title</code></td>
<td>
<p>title for axis.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_cex">cex</code></td>
<td>
<p>relative character expansion for axis label.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_las">las</code></td>
<td>
<p>if <code>0</code>, ticks labels are drawn parallel to the
axis; set to <code>1</code> for horizontal labels (see <code><a href="../../graphics/html/par.html">par</a></code>).</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_base">base</code></td>
<td>
<p>base of log transformation for <code>power.axis</code>
when <code>power = 0</code>.</p>
</td></tr>
<tr><td><code id="TransformationAxes_:_interval">interval</code></td>
<td>
<p>desired interval between tick marks on the probability
scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformations corresponding to the three functions are as follows:
</p>

<dl>
<dt><code>basicPowerAxis</code>:</dt><dd><p>Simple power transformation, 
<code class="reqn">x^{\prime }=x^{p}</code> for <code class="reqn">p\neq 0</code>
and <code class="reqn">x^{\prime }=\log x</code> for <code class="reqn">p=0</code>.</p>
</dd>
<dt><code>bcPowerAxis</code>:</dt><dd><p>Box-Cox power transformation,
<code class="reqn">x^{\prime }=(x^{\lambda }-1)/\lambda</code> 
for <code class="reqn">\lambda \neq 0</code> and <code class="reqn">x^{\prime }=\log x</code> 
for <code class="reqn">\lambda =0</code>.</p>
</dd>
<dt><code>bcnPowerAxis</code>:</dt><dd><p>Box-Cox with negatives power transformation, the Box-Cox power transformation of <code class="reqn">z = .5 * (y + (y^2 + \gamma^2)^{1/2})</code>, where <code class="reqn">\gamma</code> is strictly positive if <code class="reqn">y</code> includes negative values and non-negative otherwise.  The value of <code class="reqn">z</code> is always positive.</p>
</dd>
<dt><code>yjPowerAxis</code>:</dt><dd><p>Yeo-Johnson power transformation, 
for non-negative <code class="reqn">x</code>, the Box-Cox transformation of
<code class="reqn">x + 1</code>; for negative <code class="reqn">x</code>, the Box-Cox transformation of
<code class="reqn">|x| + 1</code> with power <code class="reqn">2 - p</code>.</p>
</dd>
<dt><code>probabilityAxis</code>:</dt><dd><p>logit or probit transformation,
logit <code class="reqn">=\log [p/(1-p)]</code>, or 
probit <code class="reqn">=\Phi^{-1}(p)</code>, where <code class="reqn">\Phi^{-1}</code> is the
standard-normal quantile function.</p>
</dd>
</dl>

<p>These functions will try to place tick marks at reasonable locations, but
producing a good-looking graph sometimes requires some fiddling with the 
<code>at</code> argument.
</p>


<h3>Value</h3>

<p>These functions are used for their side effects: to draw axes.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="../../car/help/basicPower.html">basicPower</a></code>, <code><a href="../../car/help/bcPower.html">bcPower</a></code>, <code><a href="../../car/help/yjPower.html">yjPower</a></code>, 
<code><a href="../../car/help/logit.html">logit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>UN &lt;- na.omit(UN)
par(mar=c(5, 4, 4, 4) + 0.1) # leave space on right

with(UN, plot(log(ppgdp, 10), log(infantMortality, 10)))
basicPowerAxis(0, base=10, side="above", 
  at=c(50, 200, 500, 2000, 5000, 20000), grid=TRUE, 
  axis.title="GDP per capita")
basicPowerAxis(0, base=10, side="right",
  at=c(5, 10, 20, 50, 100), grid=TRUE, 
  axis.title="infant mortality rate per 1000")

with(UN, plot(bcPower(ppgdp, 0), bcPower(infantMortality, 0)))
bcPowerAxis(0, side="above", 
  grid=TRUE, axis.title="GDP per capita")
bcPowerAxis(0, side="right",
  grid=TRUE, axis.title="infant mortality rate per 1000")

with(UN, qqPlot(logit(infantMortality/1000)))
probabilityAxis()

with(UN, qqPlot(qnorm(infantMortality/1000)))
probabilityAxis(at=c(.005, .01, .02, .04, .08, .16), scale="probit")

qqPlot(bcnPower(Ornstein$interlocks, lambda=1/3, gamma=0.1))
bcnPowerAxis(1/3, 0.1, at=c(o=0, 5, 10, 20, 40, 80))
</code></pre>

<hr /><div style="text-align: center;">[Package <em>car</em> version 3.1-2 <a href="00Index.html">Index</a>]</div>
</div>
</body></html>
